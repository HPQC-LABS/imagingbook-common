TODO: Adapt CircleFitTaubin from EN4!



package imagingbook.pub.geometry.fitting.circle.algebraic;


import Fitting.org.doube.geometry.Centroid;
import Fitting.org.doube.jama.Matrix;
import Fitting.org.doube.jama.SingularValueDecomposition;
import imagingbook.pub.geometry.basic.Pnt2d;
import imagingbook.pub.geometry.basic.PntUtils;
import imagingbook.pub.geometry.circle.GeometricCircle;

/**
 * Unfinished!!
 *
 */
public class CircleFitTaubin extends CircleFitAlgebraic {
	
	private final double[] p;	// p = (A,B,C,D) circle parameters
	
	public CircleFitTaubin(Pnt2d[] points) {
		this.p = fit(PntUtils.toDoubleArray(points));
	}
	
	/**
	 * Taubin method, SVD version (Doube)
	 * TODO: needs to be dapted to other fitters!
	 * 
	 * @param double[n][2] containing n (<i>x</i>, <i>y</i>) coordinates
	 * @return double[] containing (<i>x</i>, <i>y</i>) centre and radius
	 */
	private double[] fit(final double[][] points) {
		final int nPoints = points.length;
		if (nPoints < 3)
			throw new IllegalArgumentException("Too few points");
		final double[] centroid = Centroid.getCentroid(points);

		final double[][] zxy = new double[nPoints][3];
		final double[] z = new double[nPoints];
		double sumZ = 0;
		for (int n = 0; n < nPoints; n++) {
			final double x = points[n][0] - centroid[0];
			final double y = points[n][1] - centroid[1];
			zxy[n][1] = x;
			zxy[n][2] = y;
			z[n] = x * x + y * y;
			sumZ += z[n];
		}
		final double meanZ = sumZ / nPoints;
		final double sqrtMeanZ2 = 2 * Math.sqrt(meanZ);
		for (int n = 0; n < nPoints; n++) {
			zxy[n][0] = (z[n] - meanZ) / sqrtMeanZ2;
		}

		final Matrix ZXY = new Matrix(zxy);
		final SingularValueDecomposition svd = new SingularValueDecomposition(ZXY);
		final Matrix V = svd.getV();
		final Matrix A = V.getMatrix(0, V.getRowDimension() - 1, 2, 2);
		final double a1 = A.get(0, 0) / sqrtMeanZ2;
		A.set(0, 0, a1);
		final double[][] a = A.getArray();
		final double[] b = new double[a.length + 1];
		for (int i = 0; i < a.length; i++) {
			b[i] = a[i][0];
		}
		b[b.length - 1] = -meanZ * a1;
		final double[] centreRadius = new double[3];

		centreRadius[0] = -b[1] / (a1 * 2) + centroid[0];
		centreRadius[1] = -b[2] / (a1 * 2) + centroid[1];
		centreRadius[2] = Math.sqrt(b[1] * b[1] + b[2] * b[2] - 4 * b[0] * b[3]) / (Math.abs(b[0]) * 2);
		return centreRadius;
	}
	
	public double[] getParameters() {
		// TODO: fix this!
		throw new RuntimeException("CircleFitterTaubin cant return algebraic parameters");
		//return this.p;
	}

	@Override
	public GeometricCircle getGeometricCircle() {
		return new GeometricCircle(p);
	}

}
